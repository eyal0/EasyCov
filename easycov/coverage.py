#!/usr/bin/env python2
"""All the utilities needed for parsing coverage."""

from __future__ import division
from __future__ import print_function
import os
import xml.etree.ElementTree as ET
import re
from collections import defaultdict, namedtuple
import json
import math
from copy import deepcopy
import lcovparse
import pkg_resources

def relative_filename(filename, root_dir):
  """Get the path relative to root_dir unless it's not a subdir.

  If the filename is not a sibsdirectory of root_dir or if root_dir is None or
  empty, the original filename is returned.
  """
  if not root_dir:
    return filename
  new_path = os.path.relpath(filename, root_dir)
  if not new_path.startswith('..'):
    return new_path
  return filename

class Hits(namedtuple("Hits", ["hits", "total"])):
  """Stores the hit count of a line.

  The total should be at least 1 and the hits should be between 0 and the total.
  """
  def __float__(self):
    return self.hits / self.total
  def __eq__(self, other):
    return isinstance(other, Hits) and self.hits == other.hits and self.total == other.total
  def __ne__(self, other):
    return not self == other
  def __gt__(self, other):
    return self.hits * other.total > self.total * other.hits
  def __lt__(self, other):
    return not self >= other
  def __ge__(self, other):
    return self.hits * other.total >= self.total * other.hits
  def __le__(self, other):
    return not self > other
  @staticmethod
  def from_iter(iterable):
    """Take the first two values from the iterable to make a Hits."""
    return Hits(*[iterable[x] for x in xrange(2)])

class Coverage(object):
  """Coverage represents a coverage report of many files."""

  def __init__(self, coverage=None, version=None):
    self._coverage = coverage or defaultdict(lambda: defaultdict(lambda: None))
    self._version = version or pkg_resources.require("EasyCov")[0].version

  @staticmethod
  def from_lcov(filename, root_dir=None):
    """Reads coverage from the filename provided.

    If root_dir is provided, all paths that are below that directory have the
    root_dir prefix removed from them
    """
    with open(filename, 'r') as current_file:
      return Coverage.from_lcov_file(current_file, root_dir)

  @staticmethod
  def from_lcov_file(current_file, root_dir=None):
    """Reads coverage from the already-open file provided.

    If root_dir is provided, all paths that are below that directory have the
    root_dir prefix removed from them
    """
    json_cov = lcovparse.lcovparse(current_file.read())
    coverage = defaultdict(lambda: defaultdict(lambda: None))
    for file_coverage in json_cov:
      filename = relative_filename(file_coverage['file'], root_dir)
      for line in file_coverage['lines']:
        line_number = int(line['line'])
        coverage[filename][line_number] = max(
            coverage[filename][line_number] or Hits(-1, 0),
            Hits(1 if int(line['hit']) else 0, 1))
      # Now we go through the branches, which can override the line coverage.
      # For now, we'll write them each as an array.  That's how we'll recognize
      # what has already been recorded as branch coverage.  At the end, we'll
      # convert all arrays to Hits.
      for branch in file_coverage['branches']:
        taken = branch['taken']
        line_number = branch['line']
        branch_number = branch['branch']
        if (line_number not in coverage[filename] or
            not isinstance(coverage[filename][line_number], dict)):
          # Previously had line coverage or nothing.  Create a dict.
          coverage[filename][line_number] = {}
        coverage[filename][line_number][branch_number] = taken
    # Now clean up all the branch coverage from dicts to Hits.
    for _, file_coverage in coverage.iteritems():
      for line_number, line_coverage in file_coverage.iteritems():
        if isinstance(line_coverage, dict):
          file_coverage[line_number] = Hits(sum(bool(x) for x in line_coverage.values()),
                                            len(line_coverage))
    return Coverage(coverage)

  @staticmethod
  def from_xml(filename, root_dir=None):
    """Read coverage from xml file that is generated by python coverage.

    If root_dir is provided, all paths that are below that directory have the
    root_dir prefix removed from them
    """
    with open(filename, 'r') as current_file:
      return Coverage.from_xml_file(current_file, root_dir)

  @staticmethod
  def from_xml_file(current_file, root_dir=None):
    """Read coverage from already-open python coverage.

    If root_dir is provided, all paths that are below that directory have the
    root_dir prefix removed from them
    """
    root = ET.fromstring(current_file.read())
    source_dir = ''
    for source in root.iterfind('./sources/source'):
      source_dir = source.text

    coverage = defaultdict(lambda: defaultdict(lambda: None))
    for class_ in root.iterfind('./packages/package/classes/class'):
      filename = os.path.join(source_dir, class_.get('filename'))
      filename = relative_filename(filename, root_dir)
      for line in class_.iterfind('./lines/line'):
        if line.get('branch', 'false') == 'true':
          # This is a branch line
          condition_coverage = line.get('condition-coverage')
          matches = re.match(r'\d+%\s+\((\d+)/(\d+)\)', condition_coverage)
          new_hits = Hits(int(matches.group(1)), int(matches.group(2)))
        else:
          new_hits = Hits(int(line.get('hits', 0)), 1)
        coverage[filename][int(line.get('number'))] = max(
            coverage[filename][int(line.get('number'))] or Hits(-1, 0),
            new_hits)
    return Coverage(coverage)

  def to_json(self, *args, **kwargs):
    """Returns the coverage as a json string."""
    result = {"version": self._version,
              "coverage": self._coverage}
    return json.dumps(result, default=float, *args, **kwargs)

  @staticmethod
  def from_json(json_string):
    """Reads coverage from a json string and returns a new Coverage object."""
    json_in = json.loads(json_string)
    version = json_in['version']
    coverage = defaultdict(lambda: defaultdict(lambda: None), json_in['coverage'])
    for filename in coverage:
      # Don't use iterkeys because we are modifying the dictionary.
      for line_number in coverage[filename].keys():
        coverage[filename][int(line_number)] = Hits.from_iter(coverage[filename].pop(line_number))
    return Coverage(coverage, version)

  @staticmethod
  def _value_to_bits(val):
    """Convert a value to a byte that represents that value between 0 and 1.

    Return value 0 means that v was None.
    1 is 0/1 1
    2 is 1/1
    3 is 0/2 3
    4 is 1/2
    5 is 2/2
    6 is 0/3 6
    7 is 1/3
    8 is 2/3
    9 is 3/3
    etc.
    """
    if val is None:
      return 0
    return (val.total * (val.total+1))//2 + val.hits

  @staticmethod
  def _bits_to_value(bits):
    """Convert a byte to a value between 0 and 1.

    v should be between 0 and 255 inclusive.  0 means None.  Input 1 is 0, 2 is
    1, 3 is 1/2, 4 is 1/3, 5 is 2/3, etc.
    """
    if bits == 0:
      return None
    denom = int(math.floor((math.sqrt(1+8*bits) - 1)/2)) # Quadratic formula of denom above.
    numer = bits - Coverage._value_to_bits(Hits(0, denom))
    return Hits(numer, denom)

  def to_binary(self):
    """Returns the coverage in a much-compressed string format.

    First the version as a string followed by a 0 byte.
    Then for each file:
      filename in ascii followed by a null
      number_of_lines in the filename as a string followed by a null
      bits_per_line as a single byte, never more than 255
      Then for each line from 0 to number_of_lines-1:
        The hit value from 0 to 1 encoded into the right number of bits.
    """
    result = bytearray()
    result += self._version + b"\0"
    for filename in sorted(self._coverage.keys()):
      result += filename + b"\0"
      number_of_lines = max(self._coverage[filename].iterkeys())+1
      result += str(number_of_lines) + "\0"
      #hits is the bit-encoded value of the fraction.
      hits = [self._value_to_bits(self._coverage[filename].get(line_number, None))
              for line_number in xrange(number_of_lines)]
      bits_per_line = int(math.ceil(math.log(max(hits)+1, 2)))
      result += chr(bits_per_line)
      hit_bits = ""
      for hit in hits:
        new_val = bin(hit)[2:]
        new_val = ('0' * (bits_per_line - len(new_val))) + new_val
        hit_bits += new_val
      if len(hit_bits) % 8 != 0:
        hit_bits += '0' * (8 - len(hit_bits) % 8)
      for i in xrange(0, len(hit_bits), 8):
        result += chr(int(hit_bits[i:i+8], 2))
    return result

  @staticmethod
  def from_binary_filename(filename):
    """Reads the coverage from the binary format described in to_binary."""
    with open(filename, 'r') as current_file:
      return Coverage.from_binary(bytearray(current_file.read()))

  @staticmethod
  def from_binary(bin_coverage):
    """Reads the coverage from the binary format described in to_binary."""
    pos = 0
    version = bytearray()
    while bin_coverage[pos] != 0:
      version += chr(bin_coverage[pos])
      pos += 1
    pos += 1
    coverage = defaultdict(lambda: defaultdict(lambda: None))
    while pos < len(bin_coverage):
      filename = ""
      while bin_coverage[pos] != 0:
        filename += chr(bin_coverage[pos])
        pos += 1
      pos += 1
      number_of_lines = bytearray()
      while bin_coverage[pos] != 0:
        number_of_lines += chr(bin_coverage[pos])
        pos += 1
      pos += 1
      number_of_lines = int(number_of_lines)
      bits_per_line = bin_coverage[pos]
      pos += 1
      total_bits = number_of_lines * bits_per_line
      total_bytes = (total_bits + 7) // 8
      hit_bytes = bin_coverage[pos:pos+total_bytes]
      pos += total_bytes
      hit_bits = (bin(b)[2:] for b in hit_bytes)
      hit_bits = "".join('0'*(8-len(b)) + b for b in hit_bits)
      hits = {}
      for line_number, hit in enumerate(re.findall(("."*bits_per_line), hit_bits)):
        hit_fraction = Coverage._bits_to_value(int(hit, 2))
        if hit_fraction != None:
          hits[line_number] = hit_fraction
      coverage[filename] = hits
    return Coverage(coverage, version)

  def __eq__(self, other):
    # pylint: disable=protected-access
    if not isinstance(other, Coverage):
      return False
    if self._version != other._version:
      return False
    if sorted(self._coverage.keys()) != sorted(other._coverage.keys()):
      return False
    for filename in self._coverage.iterkeys():
      if sorted(self._coverage[filename].keys()) != sorted(other._coverage[filename].keys()):
        return False
      for line_number in self._coverage[filename].iterkeys():
        if self._coverage[filename][line_number] != other._coverage[filename][line_number]:
          return False
    return True

  def __ne__(self, other):
    return not self.__eq__(other)

  def __repr__(self):
    return "Coverage(coverage=%s, version=%s)" % (repr(self._coverage), repr(self._version))

  def __iadd__(self, other):
    # pylint: disable=protected-access
    for filename, file_coverage in other._coverage.iteritems():
      if filename not in self._coverage:
        self._coverage[filename] = deepcopy(file_coverage)
        continue
      for line, hit in file_coverage.iteritems():
        if line not in self._coverage[filename]:
          self._coverage[filename][line] = deepcopy(hit)
          continue
        self._coverage[filename][line] = max(
            self._coverage[filename][line] or Hits(-1, 0),
            hit)
    return self

  def annotate(self, root_dir):
    """Modify the files in a checkout to add annotations to them.

    When we create a coverage file, we strip away the root_dir.  But when we
    apply a coverage file, we prepend the root_dir to the filenames in the
    coverage.
    """
    for filename in self._coverage.keys():
      if not self._coverage[filename]:
        continue
      file_coverage = self._coverage[filename]
      absolute_filename = os.path.abspath(os.path.join(root_dir, filename))
      with open(absolute_filename) as lines:
        new_lines = []
        for line_number, line in enumerate(lines, 1): # Line numbers start at 1.
          if line_number in file_coverage:
            new_lines.append("%d/%d %s" %
                             (file_coverage[line_number].hits,
                              file_coverage[line_number].total,
                              line))
          elif line == "\n":
            new_lines.append(line)
          else:
            new_lines.append("    " + line)
      with open(absolute_filename, 'w') as new_file:
        new_file.write("".join(new_lines))

  def get_coverage(self, filename=None, line_number=None):
    """Return the coverage, either all of it or for one file or one line.

    This returns a copy and modifying it won't change self.
    """
    if filename is None:
      return deepcopy(self._coverage)
    if line_number is None:
      return deepcopy(self._coverage[filename])
    if not line_number in self._coverage[filename]:
      return None
    return deepcopy(self._coverage[filename][line_number])

  def get_ratio(self):
    """Returns the coverage ratio, from 1 to 1."""
    actual = 0
    expected = 0
    for _, file_coverage in self._coverage.iteritems():
      for _, hit in file_coverage.iteritems():
        expected += 1
        actual += float(hit)
    return 1 if expected == 0 else actual / expected
